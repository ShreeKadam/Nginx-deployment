pipeline {
  agent any
  tools {
    packer 'packer' // must match the name configured in Global Tool Config
  }

  parameters {
    booleanParam(name: 'DESTROY_INFRA', defaultValue: false, description: 'Destroy infrastructure after run?')
  }

  environment {
    AWS_REGION = 'us-east-1'
    PACKER_BIN = "${env.WORKSPACE}/packer/bin"
  }

  stages {

    stage('Build AMI with Packer') {
      when {
        expression { return !params.DESTROY_INFRA }
      }
      steps {
        dir('terraform') {
          withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']
          ]) {
            sh '''
              set -e
              mkdir -p ../packer/bin
              export PATH=$PATH:$(pwd)/../packer/bin

              # Download Packer if not already present
              if ! ../packer/bin/packer -v &> /dev/null; then
                echo "Downloading Packer..."
                wget https://releases.hashicorp.com/packer/1.10.0/packer_1.10.0_linux_amd64.zip
                unzip -o packer_1.10.0_linux_amd64.zip -d ../packer/bin
                chmod +x ../packer/bin/packer
              fi

              ../packer/bin/packer --version

              # Run Packer with JSON template
              cd ../packer
              ../packer/bin/packer build nginx_private_ami.json | tee packer-output.log

              # Extract AMI ID
              if [ -f ami_id.txt ]; then
                echo "AMI ID extracted from ami_id.txt"
              elif grep -q 'ami-' packer-output.log; then
                grep -o 'ami-[a-zA-Z0-9\\-]*' packer-output.log | tail -1 > ami_id.txt
              else
                echo "AMI ID not found!" && exit 1
              fi
            '''
          }
        }
        archiveArtifacts artifacts: 'packer/packer-output.log, packer/ami_id.txt', onlyIfSuccessful: true
      }
    }

    stage('Read AMI ID') {
      when {
        allOf {
          expression { return !params.DESTROY_INFRA }
          expression { return fileExists('packer/ami_id.txt') }
        }
      }
      steps {
        script {
          env.AMI_ID = readFile('packer/ami_id.txt').trim()
          echo "Using AMI ID: ${env.AMI_ID}"
        }
      }
    }

    stage('Terraform Init & Apply') {
      when {
        expression { return !params.DESTROY_INFRA }
      }
      steps {
        dir('terraform') {
          withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']
          ]) {
            sh '''
              export AWS_REGION=${AWS_REGION}
              terraform init
              terraform fmt
              terraform validate
              terraform apply -auto-approve
            '''
          }
        }
      }
    }

    stage('Inject Bastion IP and PEM into Ansible Config') {
      when {
        expression { return !params.DESTROY_INFRA }
      }
      steps {
        withCredentials([
          [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds'],
          [$class: 'SSHUserPrivateKeyBinding', credentialsId: 'nginx_key', keyFileVariable: 'SSH_KEY']
        ]) {
          script {
            def bastionIp = sh(script: "terraform -chdir=terraform output -raw bastion_public_ip", returnStdout: true).trim()
            sh """
              sed -i 's|<bastion_public_ip>|${bastionIp}|' ansible/ansible.cfg
              sed -i 's|<private_key_path>|${SSH_KEY}|' ansible/ansible.cfg
              sed -i 's|tag:Type: webserver|tag:NGINX_Private: yes|' ansible/aws_ec2.yaml || true
            """
          }
        }
      }
    }

    stage('Install NGINX with Ansible') {
      when {
        expression { return !params.DESTROY_INFRA }
      }
      steps {
        dir('ansible') {
          withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds'],
            [$class: 'SSHUserPrivateKeyBinding', credentialsId: 'nginx_key', keyFileVariable: 'SSH_KEY']
          ]) {
            sh '''
              set -e
              python3 -m venv venv
              ./venv/bin/pip install -r requirements.txt
              ./venv/bin/ansible-galaxy collection install amazon.aws

              export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
              export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
              export AWS_REGION=${AWS_REGION}

              ./venv/bin/ansible-inventory -i aws_ec2.yaml --graph
              ./venv/bin/ansible-playbook -i aws_ec2.yaml nginx.yml
            '''
          }
        }
      }
    }

    stage('Terraform Destroy (Optional)') {
      when {
        expression { return params.DESTROY_INFRA == true }
      }
      steps {
        dir('terraform') {
          withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-creds']
          ]) {
            sh '''
              export AWS_REGION=${AWS_REGION}
              terraform destroy -auto-approve
            '''
          }
        }
      }
    }
  }

  post {
    success {
      slackSend (
        channel: '#all-arizona',
        color: 'good',
        message: "*Tool Evaluation Pipeline* completed successfully. <${env.BUILD_URL}|View Job>"
      )
      mail to: 'shreekadam2222htb@gmail.com',
           subject: 'SUCCESS: Tool Evaluation Pipeline',
           body: "Build #${env.BUILD_NUMBER} succeeded.\n\nCheck Jenkins for details:\n${env.BUILD_URL}"
    }
    failure {
      slackSend (
        channel: '#all-arizona',
        color: 'danger',
        message: "*Tool Evaluation Pipeline* failed. <${env.BUILD_URL}|View Job>"
      )
      mail to: 'shreekadam2222htb@gmail.com',
           subject: 'FAILURE: Tool Evaluation Pipeline',
           body: "Build #${env.BUILD_NUMBER} failed.\n\nCheck Jenkins for details:\n${env.BUILD_URL}"
    }
    always {
      archiveArtifacts artifacts: '**/*.log, packer/ami_id.txt', onlyIfSuccessful: true
    }
  }
}
